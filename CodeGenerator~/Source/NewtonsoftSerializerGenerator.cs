using Microsoft.CodeAnalysis;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leap.Forward.Unity.Common
{
    public class NewtonsoftSerializerGenerator : GeneratorBase
    {
        private static NameAndNamespace iCollectionName = new NameAndNamespace("System.Collections.Generic.IList");

        public NewtonsoftSerializerGenerator(ITypeSymbol typeSymbolInfo, AttributeData? attribute, GeneratorExecutionContext context) : base(typeSymbolInfo, context)
        {
            if (attribute != null)
            {
                foreach (var namedArg in attribute.NamedArguments)
                {
                    if (namedArg.Key == "PreviousVersion" && namedArg.Value.Value is INamedTypeSymbol typeSymbol)
                    {
                        PreviousVersion = typeSymbol;
                    }
                    else if (namedArg.Key == "Version" && namedArg.Value.Value is int ver)
                    {
                        Version = ver;
                    }
                }
            }
        }

        public INamedTypeSymbol? PreviousVersion { get; }

        public int Version { get; }

        internal void Generate()
        {
            var fullClassName = ClassSymbol.ToString();

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            //sourceBuilder.AppendLine("using JsonVersioning;");

            var hasContainingNamespace = ClassSymbol.ContainingNamespace != null && !ClassSymbol.ContainingNamespace.IsGlobalNamespace;

            if (hasContainingNamespace)
            {
                sourceBuilder.AppendLine($"namespace {ClassSymbol.ContainingNamespace} {{");
            }

            var nestedInClasses = new List<INamedTypeSymbol>();
            var nestedIn = ClassSymbol.ContainingType;
            while (nestedIn != null)
            {
                nestedInClasses.Add(nestedIn);
                nestedIn = nestedIn.ContainingType;
            }

            nestedInClasses.Reverse();

            for (var index = 0; index < nestedInClasses.Count; index++)
            {
                var namedTypeSymbol = nestedInClasses[index];
                sourceBuilder.AppendLine($"partial class {GetClassNameWithoutNamespace(namedTypeSymbol)} {{");
            }

            var className = GetClassNameWithoutNamespace(ClassSymbol);

            sourceBuilder.AppendLine($"partial class {className} {{");

            var properties = ClassSymbol.GetMembers().OfType<IPropertySymbol>().Select(_ => new PropertyInfo(_)).Where(_=>!_.Ignore).ToList();

            sourceBuilder.AppendLine($"public {className} FromJToken(Newtonsoft.Json.Linq.JToken token)");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine("var jobject = token as Newtonsoft.Json.Linq.JObject;");
            sourceBuilder.AppendLine("if (jobject == null) throw new System.FormatException(\"Expected JObject\");");
            if (PreviousVersion != null)
            {
                sourceBuilder.AppendLine("if (!jobject.TryGetValue(\"$version\", out Newtonsoft.Json.Linq.JToken versionToken) || versionToken.Type != Newtonsoft.Json.Linq.JTokenType.Integer || Newtonsoft.Json.Linq.Extensions.Value<int>(versionToken) != " + Version + ")");
                sourceBuilder.AppendLine("{");
                sourceBuilder.AppendLine($"  var prev = new {PreviousVersion.Name}();");
                sourceBuilder.AppendLine($"  prev.FromJToken(token);");
                sourceBuilder.AppendLine($"  this.UpgradeFrom(prev);");
                sourceBuilder.AppendLine("  return this;");
                sourceBuilder.AppendLine("}");
            }
            foreach (var propertySymbol in properties)
            {
                if (!propertySymbol.HasGetter)
                    continue;

                sourceBuilder.AppendLine("{ // {propertySymbol.JsonName}");


                sourceBuilder.AppendLine($"if (jobject.TryGetValue(\"{propertySymbol.JsonName}\", out var value))");
                sourceBuilder.AppendLine("{");
                if (propertySymbol.JsonTokenConverter != null)
                {
                    sourceBuilder.AppendLine($"    this.{propertySymbol.PropertyName} = {propertySymbol.JsonTokenConverter}.FromJToken(value, this.{propertySymbol.PropertyName});");
                }
                else
                {
                    sourceBuilder.AppendLine($"if (value == null) {{ this.{propertySymbol.PropertyName} = default({propertySymbol.PropertyType.ToDisplayString()}); }} else {{");
                    sourceBuilder.AppendLine($"    var existingValue = this.{propertySymbol.PropertyName};");
                    sourceBuilder.AppendLine($"    if (existingValue == default({propertySymbol.PropertyType.ToDisplayString()})) existingValue = new {propertySymbol.PropertyType.ToDisplayString()}();");
                    if (propertySymbol.PropertyType.ImplementsInterface(iCollectionName, out var elementType))
                    {
                        sourceBuilder.AppendLine("    var array = (Newtonsoft.Json.Linq.JArray)value;");
                        sourceBuilder.AppendLine("    foreach (var item in array) {");
                        sourceBuilder.AppendLine($"        existingValue.Add((new {elementType.ToDisplayString()}()).FromJToken(item));");
                        sourceBuilder.AppendLine("    }");
                    }
                    else
                    {
                        sourceBuilder.AppendLine($"    existingValue = existingValue.FromJToken(value);");
                    }
                    if (propertySymbol.HasSetter)
                    {
                        sourceBuilder.AppendLine($"    this.{propertySymbol.PropertyName} = existingValue;");
                    }
                    sourceBuilder.AppendLine("}");
                }
                sourceBuilder.AppendLine("}");
                sourceBuilder.AppendLine("} // {propertySymbol.JsonName}");
            }
            sourceBuilder.AppendLine("return this;");
            sourceBuilder.AppendLine("}");

            sourceBuilder.AppendLine($"public Newtonsoft.Json.Linq.JToken ToJToken()");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine("var jobject = new Newtonsoft.Json.Linq.JObject();");
            if (Version != 0)
            {
                sourceBuilder.AppendLine($"jobject[\"$version\"] = {Version};");
            }

            foreach (var propertySymbol in properties)
            {
                if (!propertySymbol.HasGetter)
                    continue;

                if (propertySymbol.JsonTokenConverter != null)
                {
                    sourceBuilder.AppendLine($"jobject[\"{propertySymbol.JsonName}\"] = {propertySymbol.JsonTokenConverter.ToDisplayString()}.ToJToken(this.{propertySymbol.PropertyName});");
                }
                else
                {
                    sourceBuilder.AppendLine("{");
                    sourceBuilder.AppendLine($"var propertyValue = this.{propertySymbol.PropertyName};");
                    sourceBuilder.AppendLine($"if (propertyValue != default({propertySymbol.PropertyType.ToDisplayString()})) {{");
                    if (propertySymbol.PropertyType.ImplementsInterface(iCollectionName))
                    {
                        sourceBuilder.AppendLine("  var array = new Newtonsoft.Json.Linq.JArray();");
                        sourceBuilder.AppendLine("  foreach (var item in propertyValue)");
                        sourceBuilder.AppendLine("     array.Add(item.ToJToken());");
                        sourceBuilder.AppendLine($"  jobject[\"{propertySymbol.JsonName}\"] = array;");
                    }
                    else
                    {
                        sourceBuilder.AppendLine($"  jobject[\"{propertySymbol.JsonName}\"] = propertyValue.ToJToken();");
                    }
                    sourceBuilder.AppendLine("} }");
                }
            }
            sourceBuilder.AppendLine("return jobject;");
            sourceBuilder.AppendLine("}");

            sourceBuilder.AppendLine("}");

            foreach (var namedTypeSymbol in nestedInClasses)
            {
                sourceBuilder.AppendLine("}");
            }

            if (hasContainingNamespace)
            {
                sourceBuilder.AppendLine("}");
            }

            string sanitizedFileName = SanitizeFileName(fullClassName);
            Context.AddSource($"{sanitizedFileName}.g.cs", sourceBuilder.ToString());
        }

        class PropertyInfo
        {
            private static NameAndNamespace jsonTokenConverterAttributeName = new NameAndNamespace("Leap.Forward.JsonVersioning.JsonTokenConverterAttribute");
            private static NameAndNamespace jsonPropertyAttributeName = new NameAndNamespace("Newtonsoft.Json.JsonPropertyAttribute");
            private static NameAndNamespace jsonIgnoreAttributeName = new NameAndNamespace("Newtonsoft.Json.JsonIgnoreAttribute");


            public PropertyInfo(IPropertySymbol propertySymbol)
            {
                JsonName = PropertyName = propertySymbol.Name;
                PropertyType = propertySymbol.Type;
                Ignore = propertySymbol.GetAttributes().FirstOrDefault(ad =>
                  ad.AttributeClass.Is(jsonIgnoreAttributeName)) != null;
                HasGetter = propertySymbol.GetMethod != null;

                if (!Ignore)
                {

                    HasSetter = propertySymbol.SetMethod != null;
                    var jsonProperty = propertySymbol.GetAttributes().FirstOrDefault(ad =>
                        ad.AttributeClass.Is(jsonPropertyAttributeName));

                    if (jsonProperty != null && jsonProperty.ConstructorArguments.Length > 0)
                    {
                        JsonName = (jsonProperty.ConstructorArguments[0].Value as string) ?? JsonName;
                    }

                    var jsonTokenConverter = propertySymbol.GetAttributes().FirstOrDefault(ad =>
                        ad.AttributeClass.Is(jsonTokenConverterAttributeName));
                    if (jsonTokenConverter != null)
                    {
                        if (jsonTokenConverter.ConstructorArguments[0].Value is INamedTypeSymbol typeSymbol)
                        {
                            JsonTokenConverter = typeSymbol;
                        }
                    }
                }
            }

            public string JsonName { get; }
            public ITypeSymbol PropertyType { get; }
            public string PropertyName { get; }
            public bool Ignore { get; }
            public bool HasGetter { get; }
            public bool HasSetter { get; }
            public AttributeData? JsonProperty { get; }
            public INamedTypeSymbol? JsonTokenConverter { get; }
        }

    }

}