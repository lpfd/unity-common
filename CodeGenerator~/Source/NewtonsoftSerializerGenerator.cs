using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Leap.Forward.Unity.Common
{
    public class NewtonsoftSerializerGenerator : GeneratorBase
    {
        public NewtonsoftSerializerGenerator(ITypeSymbol typeSymbolInfo, AttributeData? attribute, GeneratorExecutionContext context) : base(typeSymbolInfo, context)
        {
            if (attribute != null)
            {
                foreach (var namedArg in attribute.NamedArguments)
                {
                    if (namedArg.Key == "PreviousVersion" && namedArg.Value.Value is INamedTypeSymbol typeSymbol)
                    {
                        PreviousVersion = typeSymbol;
                    }
                    else if (namedArg.Key == "Version" && namedArg.Value.Value is int ver)
                    {
                        Version = ver;
                    }
                }
            }
        }

        public INamedTypeSymbol? PreviousVersion { get; }

        public int Version { get; }

        private string jsonPropertyAttributeName = "Newtonsoft.Json.JsonPropertyAttribute";
        private string jsonIgnoreAttributeName = "Newtonsoft.Json.JsonIgnoreAttribute";

        internal void Generate()
        {
            var fullClassName = ClassSymbol.ToString();

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            //sourceBuilder.AppendLine("using JsonVersioning;");

            var hasContainingNamespace = ClassSymbol.ContainingNamespace != null && !ClassSymbol.ContainingNamespace.IsGlobalNamespace;

            if (hasContainingNamespace)
            {
                sourceBuilder.AppendLine($"namespace {ClassSymbol.ContainingNamespace} {{");
            }

            var nestedInClasses = new List<INamedTypeSymbol>();
            var nestedIn = ClassSymbol.ContainingType;
            while (nestedIn != null)
            {
                nestedInClasses.Add(nestedIn);
                nestedIn = nestedIn.ContainingType;
            }

            nestedInClasses.Reverse();

            for (var index = 0; index < nestedInClasses.Count; index++)
            {
                var namedTypeSymbol = nestedInClasses[index];
                sourceBuilder.AppendLine($"partial class {GetClassNameWithoutNamespace(namedTypeSymbol)} {{");
            }

            var className = GetClassNameWithoutNamespace(ClassSymbol);

            sourceBuilder.AppendLine($"partial class {className} {{");

            sourceBuilder.AppendLine($"public static {className} ReadJson(Newtonsoft.Json.Linq.JObject jobject, Newtonsoft.Json.JsonSerializer serializer)");
            sourceBuilder.AppendLine("{");
            if (PreviousVersion != null)
            {
                sourceBuilder.AppendLine("if (!jobject.TryGetValue(\"$version\", out Newtonsoft.Json.Linq.JToken versionToken) || versionToken.Type != Newtonsoft.Json.Linq.JTokenType.Integer || Newtonsoft.Json.Linq.Extensions.Value<int>(versionToken) != " + Version + ")");
                sourceBuilder.AppendLine("{");
                sourceBuilder.AppendLine($"return new {className}({PreviousVersion.Name}.ReadJson(jobject, serializer));");
                sourceBuilder.AppendLine("}");
            }
            sourceBuilder.AppendLine($"var result = new {className}();");
            foreach (var propertySymbol in ClassSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                var propertyName = propertySymbol.Name;
                var hasGetter = propertySymbol.GetMethod != null;
                var hasSetter = propertySymbol.SetMethod != null;
                var jsonProperty = propertySymbol.GetAttributes().FirstOrDefault(ad =>
                    ad.AttributeClass?.ToDisplayString() == jsonPropertyAttributeName);
                var jsonIgnore = propertySymbol.GetAttributes().FirstOrDefault(ad =>
                    ad.AttributeClass?.ToDisplayString() == jsonIgnoreAttributeName);

                if (jsonIgnore != null || !hasSetter)
                    continue;

                var jsonPropertyName = propertyName;
                if (jsonProperty != null && jsonProperty.ConstructorArguments.Length > 0)
                {
                    jsonPropertyName = (jsonProperty.ConstructorArguments[0].Value as string) ?? jsonPropertyName;
                }
                sourceBuilder.AppendLine($"if (jobject.TryGetValue(\"{jsonPropertyName}\", out var value))");
                sourceBuilder.AppendLine("{");
                sourceBuilder.AppendLine($"    result.{propertyName} = value.ToObject<{propertySymbol.Type.ToDisplayString()}>();");
                sourceBuilder.AppendLine("}");
            }
            sourceBuilder.AppendLine($"return result;");
            sourceBuilder.AppendLine("}");

            sourceBuilder.AppendLine($"public void WriteJson(Newtonsoft.Json.JsonWriter  writer, Newtonsoft.Json.JsonSerializer serializer)");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine("var jobject = new Newtonsoft.Json.Linq.JObject();");
            if (Version != 0)
            {
                sourceBuilder.AppendLine($"jobject[\"$version\"] = {Version};");
            }
            foreach (var propertySymbol in ClassSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                var propertyName = propertySymbol.Name;
                var hasGetter = propertySymbol.GetMethod != null;
                var hasSetter = propertySymbol.SetMethod != null;
                var jsonProperty = propertySymbol.GetAttributes().FirstOrDefault(ad =>
                    ad.AttributeClass?.ToDisplayString() == jsonPropertyAttributeName);
                var jsonIgnore = propertySymbol.GetAttributes().FirstOrDefault(ad =>
                    ad.AttributeClass?.ToDisplayString() == jsonIgnoreAttributeName);

                if (jsonIgnore != null || !hasGetter)
                    continue;

                var jsonPropertyName = propertyName;
                if (jsonProperty != null && jsonProperty.ConstructorArguments.Length > 0)
                {
                    jsonPropertyName = (jsonProperty.ConstructorArguments[0].Value as string) ?? jsonPropertyName;
                }

                sourceBuilder.AppendLine($"jobject[\"{jsonPropertyName}\"] = Newtonsoft.Json.Linq.JToken.FromObject(this.{propertyName}, serializer);");
            }
            sourceBuilder.AppendLine("jobject.WriteTo(writer);");
            sourceBuilder.AppendLine("}");

            sourceBuilder.AppendLine("}");

            foreach (var namedTypeSymbol in nestedInClasses)
            {
                sourceBuilder.AppendLine("}");
            }

            if (hasContainingNamespace)
            {
                sourceBuilder.AppendLine("}");
            }

            string sanitizedFileName = SanitizeFileName(fullClassName);
            Context.AddSource($"{sanitizedFileName}.g.cs", sourceBuilder.ToString());
        }
    }

}